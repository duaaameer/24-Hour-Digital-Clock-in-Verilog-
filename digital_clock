`timescale 1ns / 1ps


module digital_clock(
    input clk,
    input en,
    input rst,
    input hrup,
    input minup,
    output [3:0] s1,  // Seconds (ones place)
    output [3:0] s2,  // Seconds (tens place)
    output [3:0] m1,  // Minutes (ones place)
    output [3:0] m2,  // Minutes (tens place)
    output [3:0] h1,  // Hours (ones place)
    output [3:0] h2   // Hours (tens place)
);
    // Registers for timekeeping
    reg [5:0] hour = 0, min = 0, sec = 0;
    reg [31:0] clkc = 0;
    localparam onesec = 100_000_000; // 1 Second

    always @(posedge clk) begin
        // Reset clock
        if (rst == 1'b1) begin
            hour <= 0;
            min <= 0;
            sec <= 0;
        end 
        // Set clock manually
        else if (minup == 1'b1) begin
            if (min == 6'd59)
                min <= 0;
            else
                min <= min + 1;
        end else if (hrup == 1'b1) begin
            if (hour == 6'd23)
                hour <= 0;
            else
                hour <= hour + 1;
        end 
        // Increment clock
        else if (en == 1'b1) begin
            if (clkc == onesec - 1) begin
                clkc <= 0;
                if (sec == 6'd59) begin
                    sec <= 0;
                    if (min == 6'd59) begin
                        min <= 0;
                        if (hour == 6'd23)
                            hour <= 0;
                        else
                            hour <= hour + 1;
                    end else
                        min <= min + 1;
                end else
                    sec <= sec + 1;
            end else
                clkc <= clkc + 1;
        end
    end

    // BCD conversion modules
    binarytoBCD secs (.binary(sec), .thous(), .hund(), .tens(s2), .once(s1));
    binarytoBCD mins (.binary(min), .thous(), .hund(), .tens(m2), .once(m1));
    binarytoBCD hours (.binary(hour), .thous(), .hund(), .tens(h2), .once(h1));

endmodule
